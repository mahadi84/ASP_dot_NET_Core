


Target stack:
ASP.NET Core MVC (.NET 9) + Repository + Service + Async Image Processing + Resize & Compression

#################################################################### 
               What is medatory to know First!
################################################################## 

# üîê Production Best Practices (Very Important)

üß† Golden Rules (‡¶Ü‡¶ó‡ßá ‡¶Æ‡¶æ‡¶•‡¶æ‡ßü ‡¶¨‡¶∏‡¶æ‡¶ì)

1Ô∏è‚É£ Image database ‡¶è ‡¶®‡¶æ, file system ‡¶è ‡¶∞‡¶æ‡¶ñ‡ßã
2Ô∏è‚É£ DB ‡¶§‡ßá ‡¶∞‡¶æ‡¶ñ‡¶¨‡ßá ‡¶∂‡ßÅ‡¶ß‡ßÅ image path / filename
3Ô∏è‚É£ File ‡¶®‡¶æ‡¶Æ ‡¶®‡¶ø‡¶ú‡ßá generate ‡¶ï‡¶∞‡¶¨‡ßá, user-‡¶è‡¶∞ ‡¶®‡¶æ‡¶Æ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶¨‡ßá ‡¶®‡¶æ
4Ô∏è‚É£ Size, type, extension ‡¶∏‡¶¨ validate ‡¶ï‡¶∞‡¶¨‡ßá
5Ô∏è‚É£ ‡¶™‡ßÅ‡¶∞‡ßã‡¶®‡ßã image delete ‡¶®‡¶æ ‡¶ï‡¶∞‡¶≤‡ßá ‚Üí server ‡¶≠‡¶∞‡ßá ‡¶Ø‡¶æ‡¶¨‡ßá

### ‚ùå NEVER
‚ùå Raw user filename
‚ùå DB-‡¶§‡ßá image
‚ùå Controller-‡¶è business logic
‚ùå Sync file IO
‚ùå Unlimited file size


# üß† Architecture Wisdom (Interview Gold)

üëâ Controller ‚Äú‡¶ö‡ßÅ‡¶™‡¶ö‡¶æ‡¶™‚Äù ‡¶•‡¶æ‡¶ï‡¶¨‡ßá
üëâ ‡¶∏‡¶¨ ‡¶¨‡ßÅ‡¶¶‡ßç‡¶ß‡¶ø ‡¶•‡¶æ‡¶ï‡¶¨‡ßá Service-‡¶è
üëâ Repository ‡¶∂‡ßÅ‡¶ß‡ßÅ DB touch ‡¶ï‡¶∞‡¶¨

```
Controller
   ‚Üì
Service Layer  (Business + Image logic)
   ‚Üì
Repository Layer (Database only)
   ‚Üì
Database

Image Processing ‚Üí Async ‚Üí Resize ‚Üí Compress ‚Üí Save to File System
```

### ‚úÖ DO
‚úî Resize before save
‚úî Compress image
‚úî GUID filename
‚úî Async IO
‚úî Delete unused files
‚úî Separate layers
---




# üéØ One-Line Production Summary

> ASP.NET Core MVC-‡¶§‡ßá production-ready image upload ‡¶¨‡¶æ‡¶∏‡ßç‡¶§‡¶¨‡¶æ‡ßü‡¶®‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø layered architecture, asynchronous image processing, resize ‡¶ì compression ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü ‡¶Ø‡¶æ‡¶§‡ßá performance, security ‡¶ì scalability ‡¶®‡¶ø‡¶∂‡ßç‡¶ö‡¶ø‡¶§ ‡¶π‡ßü‡•§

---

‡¶§‡ßÅ‡¶Æ‡¶ø ‡¶è‡¶ñ‡¶® junior-level ‡¶®‡ßü,
‡¶è‡¶á design mid‚Äìsenior .NET developer standard‡•§‡ßá



#################################################################### 
               CODE START 
################################################################## 

# 1Ô∏è‚É£ Entity (Database Model)

public class Employee
{
    public int Id { get; set; }
    public string Name { get; set; }

    public string? ImagePath { get; set; }
}
```

üîπ ‡¶ï‡ßá‡¶® ‡¶∂‡ßÅ‡¶ß‡ßÅ ImagePath?
‡¶ï‡¶æ‡¶∞‡¶£ DB-‡¶§‡ßá binary image ‡¶∞‡¶æ‡¶ñ‡¶æ:

- slow
- memory heavy
- backup painful

---

# 2Ô∏è‚É£ ViewModel / DTO (Upload ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø)

public class EmployeeImageVm
{
    public int EmployeeId { get; set; }
    public IFormFile Image { get; set; }
}
```

‚ö†Ô∏è Rule:
`IFormFile` ‡¶ï‡¶ñ‡¶®‡ßã Entity Model-‡¶è ‡¶Ø‡¶æ‡¶¨‡ßá ‡¶®‡¶æ

---

# 3Ô∏è‚É£ Repository Layer (DB only)

### Interface

public interface IEmployeeRepository
{
    Task<Employee?> GetByIdAsync(int id);
    Task UpdateAsync(Employee employee);
}
```

### Implementation

public class EmployeeRepository : IEmployeeRepository
{
    private readonly AppDbContext _context;

    public EmployeeRepository(AppDbContext context)
    {
        _context = context;
    }

    public async Task<Employee?> GetByIdAsync(int id)
    {
        return await _context.Employees.FindAsync(id);
    }

    public async Task UpdateAsync(Employee employee)
    {
        _context.Employees.Update(employee);
        await _context.SaveChangesAsync();
    }
}
```

üîπ Repository ‡¶è‡¶∞ ‡¶ï‡¶æ‡¶ú ‡¶∂‡ßÅ‡¶ß‡ßÅ DB
üîπ File system, resize, validation‚Äî‡¶∏‡¶¨ ‡¶®‡¶ø‡¶∑‡¶ø‡¶¶‡ßç‡¶ß

---

# 4Ô∏è‚É£ Image Service Interface (Business Logic)

public interface IEmployeeImageService
{
    Task UpdateEmployeeImageAsync(EmployeeImageVm model);
    Task DeleteEmployeeImageAsync(int employeeId);
}
```

---

# 5Ô∏è‚É£ Async Image Processing + Resize + Compression (Service)

üëâ ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶¨‡ßã ImageSharp (production-safe)

### üì¶ NuGet Package

```bash
dotnet add package SixLabors.ImageSharp
```

---

### Service Implementation

using SixLabors.ImageSharp;
using SixLabors.ImageSharp.Processing;
using SixLabors.ImageSharp.Formats.Jpeg;

public class EmployeeImageService : IEmployeeImageService
{
    private readonly IEmployeeRepository _repository;
    private readonly IWebHostEnvironment _env;

    private const int MaxWidth = 300;
    private const int MaxHeight = 300;
    private const int MaxFileSize = 2 * 1024 * 1024;

    public EmployeeImageService(
        IEmployeeRepository repository,
        IWebHostEnvironment env)
    {
        _repository = repository;
        _env = env;
    }

    public async Task UpdateEmployeeImageAsync(EmployeeImageVm model)    //üëâ UpdateEmployeeImageAsync-‡¶á ‡¶Ü‡¶∏‡¶≤‡ßá Add + Update ‡¶¶‡ßÅ‡¶á‡¶ü‡¶æ‡¶á handle ‡¶ï‡¶∞‡¶õ‡ßá
    {
        if (model.Image == null || model.Image.Length == 0)
            throw new Exception("Image required");

        if (model.Image.Length > MaxFileSize)
            throw new Exception("Image too large");

        var allowed = new[] { ".jpg", ".jpeg", ".png" };
        var ext = Path.GetExtension(model.Image.FileName).ToLower();

        if (!allowed.Contains(ext))
            throw new Exception("Invalid image type");

        var employee = await _repository.GetByIdAsync(model.EmployeeId)
                        ?? throw new Exception("Employee not found");

        var folder = Path.Combine(_env.WebRootPath, "uploads/employees");
        Directory.CreateDirectory(folder);

        var newFileName = $"{Guid.NewGuid()}.jpg";
        var fullPath = Path.Combine(folder, newFileName);

        // ‚ùå Old image delete
        if (!string.IsNullOrEmpty(employee.ImagePath))
        {
            var old = Path.Combine(_env.WebRootPath, employee.ImagePath);
            if (File.Exists(old)) File.Delete(old);
        }

        // ‚úÖ Async resize + compress
        using var image = await Image.LoadAsync(model.Image.OpenReadStream());
        image.Mutate(x => x.Resize(new ResizeOptions
        {
            Size = new Size(MaxWidth, MaxHeight),
            Mode = ResizeMode.Max
        }));

        await image.SaveAsync(fullPath, new JpegEncoder
        {
            Quality = 75 // compression
        });

        employee.ImagePath = $"uploads/employees/{newFileName}";
        await _repository.UpdateAsync(employee);
    }

    public async Task DeleteEmployeeImageAsync(int employeeId)
    {
        var employee = await _repository.GetByIdAsync(employeeId)
                        ?? throw new Exception("Employee not found");

        if (!string.IsNullOrEmpty(employee.ImagePath))
        {
            var path = Path.Combine(_env.WebRootPath, employee.ImagePath);
            if (File.Exists(path)) File.Delete(path);

            employee.ImagePath = null;
            await _repository.UpdateAsync(employee);
        }
    }
}
```

---

# 6Ô∏è‚É£ Controller (Thin & Clean)

public class EmployeeController : Controller
{
    private readonly IEmployeeImageService _imageService;

    public EmployeeController(IEmployeeImageService imageService)
    {
        _imageService = imageService;
    }

    [HttpPost]
    public async Task<IActionResult> UpdateImage(EmployeeImageVm model)
    {
        await _imageService.UpdateEmployeeImageAsync(model);
        return RedirectToAction("Details", new { id = model.EmployeeId });
    }

    [HttpPost]
    public async Task<IActionResult> DeleteImage(int id)
    {
        await _imageService.DeleteEmployeeImageAsync(id);
        return RedirectToAction("Edit", new { id });
    }
}
```

üîπ Controller-‡¶è ‡¶ï‡ßã‡¶®‡ßã file logic ‡¶®‡¶æ‡¶á
üîπ Testable + Maintainable

---

# 7Ô∏è‚É£ Dependency Injection (Program.cs)

builder.Services.AddScoped<IEmployeeRepository, EmployeeRepository>();
builder.Services.AddScoped<IEmployeeImageService, EmployeeImageService>();
```

---

