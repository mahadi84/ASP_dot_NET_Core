


### সমস্যাটি কী? (The Scenario)

ধরুন, আপনার অ্যাকাউন্টে ৫,০০০ টাকা আছে।
১. একই সময়ে (At 10:00:01 AM): আপনি নিজে ৫০০ টাকা খরচ করছেন, আবার আপনার বন্ধু আপনাকে ২,০০০ টাকা পাঠাচ্ছে।
২. সিস্টেম প্রসেস: দুটি রিকোয়েস্টই ডাটাবেস থেকে দেখলো আপনার ব্যালেন্স ৫,০০০ টাকা।
৩. ফলাফল:  আপনার খরচ করা সার্ভিস হিসাব করবে: : 5000−500=4500 টাকা। * বন্ধুর পাঠানো সার্ভিস হিসাব করবে: 5000+2000=7000 টাকা।

৪. বিপদ: 
যে সার্ভিসটি সবার শেষে সেভ (Save) হবে, সেটি আগের ব্যালেন্সকে মুছে দেবে। 
যদি আপনার বন্ধুর ট্রানজ্যাকশন শেষে সেভ হয়, 
তবে আপনার ৫০০ টাকা খরচের কোনো রেকর্ডই ব্যালেন্সে থাকবে না!



### `RowVersion` কীভাবে এটি সমাধান করে?

ব্যাংকিং সিস্টেমে `RowVersion` ব্যবহার করা হয় মূলত ডাটাবেসে "Race Condition" বা "Double Spending" সমস্যা ঠেকানোর জন্য। 
এটি অত্যন্ত গুরুত্বপূর্ণ কারণ টাকার হিসেব এক পয়সা এদিক সেদিক হলেও বড় বিপদ হতে পারে।


`RowVersion` হলো একটি টাইমস্ট্যাম্প বা একটি ইউনিক সিগনেচার যা ডাটাবেসের প্রতিটি রো (Row) আপডেট হওয়ার সাথে সাথে অটোমেটিক বদলে যায়।

১. আপনি যখন ডাটা রিড করেন, তখন সিস্টেম `RowVersion` টিও সাথে নিয়ে আসে (ধরুন এর মান `AAA`)।
২. আপনি যখন ব্যালেন্স আপডেট করে ডাটাবেসে পাঠাবেন, ডাটাবেস চেক করবে: "এখনো কি এই রো-এর ভার্সন `AAA` আছে?"
৩. যদি এর মধ্যে আপনার বন্ধু ব্যালেন্স আপডেট করে দেয়, তবে ডাটাবেসে ভার্সনটি বদলে `BBB` হয়ে যাবে।
৪. এখন আপনার সার্ভিস যখন `AAA` ভার্সন নিয়ে আপডেট করতে যাবে, ডাটাবেস দেখবে ভার্সন মেলেনি। সে সাথে সাথে আপডেটটি Reject করে দেবে এবং একটি Concurrency Exception থ্রো করবে।


ব্যাংকিং অ্যাপে যখন কনফ্লিক্ট হয়, তখন সাধারণত নিচের ৩টি পদ্ধতির যেকোনো একটি ফলো করা হয়:

1. Client Wins: ইউজারের পাঠানো ডেটাই Force করে Save করা (ব্যাংকিংয়ে এটি করা হয় না, কারণ এতে টাকা ভুল হতে পারে)।
2. Database Wins: ডাটাবেসে যা আছে তাই থাকবে, ইউজারের রিকোয়েস্ট Cancel হবে।
3. Retry (সেরা উপায়): সিস্টেম অটোমেটিক আবার নতুন ব্যালেন্স রিড করবে এবং পুনরায় হিসাব করে সেভ করার চেষ্টা করবে (যতক্ষণ না ভার্সন মিলে যাচ্ছে)।



---

### কেন এটি আপনার প্রজেক্টের জন্য আশীর্বাদ?

আপনি যে Pubali Bank বা বড় কোনো ব্যাংকের প্রজেক্ট করবেন, সেখানে হাজার হাজার মানুষ একসাথে অ্যাপ ব্যবহার করবে।

- একই টাকা দুইবার খরচ হয়ে যেতে পারত।
- অথবা ব্যালেন্স আপডেটের সময় একজনের টাকা অন্যজনের হিসেবে চলে যেতে পারত।
- টাকা হারানো থেকে রক্ষা: এটি নিশ্চিত করে যে কোনো ট্রানজ্যাকশন অন্য ট্রানজ্যাকশনের ওপর দিয়ে "Overwrite" হয়ে যাবে না।
- Performance: এটি ডাটাবেসকে দীর্ঘক্ষণ লক (Lock) করে রাখে না (যাকে বলে Optimistic Locking), ফলে সিস্টেম দ্রুত কাজ করে।
- Data Integrity: ব্যাংকিং ডেটার নির্ভুলতা শতভাগ নিশ্চিত থাকে।

### আপনার জন্য টিপস:

Entity Framework Core-এ যখন আপনি এই `RowVersion` ব্যবহার করবেন, তখন ডাটাবেস প্রোভাইডার (যেমন SQL Server) অটোমেটিক এটি মেইনটেইন করবে। 
আপনাকে কোডে এটি ম্যানুয়ালি আপডেট করতে হবে না।

আপনি কি চান আমি আপনাকে দেখাব কীভাবে এই Concurrency Exception হ্যান্ডেল করার জন্য একটি `Try-Catch` ব্লক লিখতে হয়?


###################################################

চমৎকার! যখন একই সময়ে দুটি ট্রানজ্যাকশন ব্যালেন্স আপডেট করার চেষ্টা করে এবং `RowVersion` এর কারণে একটি ফেইল করে, তখন আমাদের `DbUpdateConcurrencyException` হ্যান্ডেল করতে হয়।
নিচে একটি ব্যাংকিং ট্রানজ্যাকশনের উদাহরণ দেওয়া হলো যেখানে আমরা এই কনফ্লিক্ট বা সংঘর্ষ হ্যান্ডেল করছি:


### Concurrency Exception হ্যান্ডেল করার কোড

public async Task<bool> UpdateBalanceWithConcurrency(Guid accountId, decimal amount)
{
    try
    {
        // ১. ডাটাবেস থেকে অ্যাকাউন্ট ডাটা আনা (RowVersion সহ)
        var account = await _context.Accounts.FindAsync(accountId);
        
        if (account == null) return false;

        // ২. ব্যালেন্স আপডেট করা
        account.Balance += amount;

        // ৩. সেভ করার চেষ্টা করা
        await _context.SaveChangesAsync();
        return true;
    }
    catch (DbUpdateConcurrencyException ex)
    {
        // ৪. যদি এখানে আসে, তার মানে আপনি যখন রিড করেছেন আর যখন সেভ করছেন, 
        // তার মাঝে অন্য কেউ ডাটা বদলে দিয়েছে।
        
        Console.WriteLine("Concurrency conflict detected! Retrying...");
        
        // এখানে আপনি ২টা কাজ করতে পারেন:
        // ক. ইউজারকে বলতে পারেন "Transaction failed, please try again."
        // খ. অথবা অটোমেটিক আবার ডাটা রিড করে চেষ্টা করতে পারেন (Retry Logic)।
        
        return false; 
    }
}



### আপনার পরবর্তী ধাপ:

আপনার ডাটাবেস এবং ডোমেইন মডেল এখন অনেক বেশি "Bulletproof" বা নিরাপদ। 
আপনি কি চান আমি আপনাকে দেখাব কীভাবে Unit Testing এর মাধ্যমে চেক করতে হয় যে আপনার এই `RowVersion` ঠিকমতো কনফ্লিক্ট ধরতে পারছে কি না? 
এটি একজন আর্কিটেক্টের জন্য খুবই জরুরি স্কিল।






.
