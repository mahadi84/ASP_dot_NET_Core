

## Database table (`users`) ‚Äî security holes + best-practice fixes

Your table is a solid start (unique username, password_hash, lockout fields, audit fields). The main issues are (1) missing referential integrity for audit fields, (2) role storage as `ENUM` (hard to evolve and can cause mapping bugs), (3) concurrency not enforced at DB level, and (4) case-sensitivity/normalization problems for username.

### 1) Username uniqueness can be bypassed by case/space variants

Right now you ‚Äútrim‚Äù in code, but DB will still allow weird edge cases depending on collation (e.g., `User1` vs `user1`, trailing spaces, Unicode lookalikes). Best practice is to store a normalized username and enforce uniqueness on that.

**Solution idea (MySQL):** add `username_normalized` and unique index on it, and always write uppercase/trimmed there from the app. If you can‚Äôt add a column, at least ensure the column collation is case-insensitive and you always trim+lower/upper in code consistently.

### 2) Audit fields should be foreign keys (and allow NULL properly)

`created_by`, `updated_by`, `approved_by` are security/audit-critical, but you‚Äôre not enforcing that they point to real users. Also, if a creator user is deleted, what happens? Decide policy: either prevent deletes, or keep users forever but mark inactive.

**Solution:** add FK constraints to `users(id)` (self-referencing), usually with `ON DELETE RESTRICT` or `SET NULL` for updated/approved.

### 3) Optimistic concurrency should be enforced in UPDATE statements

You have `row_version`, but your update query does **not** check it in the `WHERE`. That means two editors can overwrite each other silently. Concurrency control is not just ‚Äúincrement row_version‚Äù; it must be ‚Äúupdate only if row_version matches what the user last read‚Äù.

### 4) `ENUM role` is convenient but brittle

`ENUM('HoSuperAdmin',...)` is okay for small apps, but it becomes painful when roles change (migration + code mapping + permission system). It also creates mapping issues with Dapper/enum in C# if you don‚Äôt handle it carefully.

**Best practice:** store role as `TINYINT` (matching your `UserRole` enum values) or use a separate `roles` table. If you must keep `ENUM`, then treat it as a string end-to-end and don‚Äôt map it to an int enum without conversion.

### 5) Timezones and timestamps

You mix `DateTime.UtcNow`, `DateTime.Now`, MySQL `TIMESTAMP` defaults, etc. For security/audit correctness, stick to UTC everywhere (DB + app). In .NET use `DateTime.UtcNow` or better `DateTimeOffset.UtcNow`. In DB, store UTC and format in UI.

---

## Your C# domain + DTO + service ‚Äî security holes and correctness bugs

### 1) **Critical bug:** `UpdateGeneralInfo` checks the wrong variable

In `UpdateGeneralInfo` you wrote:

```csharp
if (RowVersion <= 0) throw new Exception("RowVersion is missing");
...
RowVersion = rowVersion + 1;
```

You are validating the *property* `RowVersion` instead of the *parameter* `rowVersion`. If the object‚Äôs RowVersion is already >0, this check passes even if the caller provided 0/garbage. It should validate the parameter.

Also `UpdatedAt = DateTime.Now;` should be UTC.

**Fix:**

```csharp
public void UpdateGeneralInfo(
    string username,
    UserRole role,
    int branchId,
    bool isActive,
    bool isLocked,
    int currentRowVersion,
    int updatedBy,
    DateTime nowUtc)
{
    username = ValidateUsername(username);
    if (branchId <= 0) throw new Exception("BranchId is required.");
    if (currentRowVersion <= 0) throw new Exception("RowVersion is missing.");
    if (currentRowVersion != RowVersion) throw new Exception("Concurrency conflict. Data is outdated.");

    Username = username;
    Role = role;
    BranchId = branchId;
    IsActive = isActive;
    IsLocked = isLocked;

    RowVersion = RowVersion + 1;
    UpdatedBy = updatedBy;
    UpdatedAt = nowUtc;
}
```

That `currentRowVersion != RowVersion` check is useful, but the **real enforcement must happen in SQL** too (see below), because multiple app servers can still race.

### 2) **Critical bug:** Your UPDATE SQL sets `role = Role` (missing `@`)

This line:

```sql
role = Role,
```

‚Ä¶should be:

```sql
role = @Role,
```

Otherwise MySQL will try to set role = role-column (or treat it as identifier) and you‚Äôll get wrong behavior or errors depending on SQL mode.

### 3) Concurrency is not enforced in the UPDATE query

Right now you do:

```sql
WHERE id = @Id
```

You must do:

```sql
WHERE id = @Id AND row_version = @ExpectedRowVersion
```

‚Ä¶and if affectedRows == 0, return ‚ÄúSomeone updated this record. Please reload.‚Äù

**Correct pattern:**

```csharp
const string updateSql = @"
UPDATE users
SET
    username = @Username,
    role = @Role,
    branch_id = @BranchId,
    is_active = @IsActive,
    is_locked = @IsLocked,
    updated_by = @UpdatedBy,
    updated_at = @UpdatedAt,
    row_version = row_version + 1
WHERE id = @Id AND row_version = @ExpectedRowVersion;";
```

Then pass `ExpectedRowVersion = dto.RowVersion`. Notice we increment in SQL (`row_version = row_version + 1`) so it‚Äôs atomic and race-safe.

### 4) Dapper mapping issue: DB stores role as string ENUM but C# expects `UserRole` enum

Your `users.role` is an `ENUM` string like `"Maker"`, but in C# `UserRole` is numeric `1..5`. Dapper can‚Äôt reliably map `"Maker"` into `UserRole` unless you configure type handlers or you store numeric in DB.

That‚Äôs why this line is risky:

```csharp
var user = await conn.QueryFirstOrDefaultAsync<AppUser>(checkSql, ...);
```

Because `AppUser.Role` may remain default `Maker`, making your OldValue wrong and potentially your update wrong.

**Safer quick fix:** read old data into a small DTO with `string Role` then parse, or change DB to store `TINYINT`.

### 5) Lockout fields exist but your update path can be abused

Because your update allows setting `IsLocked` and `FailedAttempts` from the UI DTO, any user who can hit that endpoint can tamper with lockout state unless authorization is strict. These should generally be server-controlled fields. The UI should not be able to submit `FailedAttempts`, and `IsLocked` should be admin-only with explicit permission checks.

### 6) DTO issues (correctness + security)

In `GetAllUsersIdAndNameDTO` constructor you have a bug:

```csharp
UserName = UserName;
```

It should be:

```csharp
UserName = userName;
```

Also your SQL for dropdown uses `user_name` column, but the table has `username`. That‚Äôs a runtime bug.

Password regex is also weak and artificially restrictive. Security-wise, don‚Äôt block strong passwords. Better: only enforce length (e.g., 12‚Äì128) and allow all characters; then hash with BCrypt (you already do). Complexity rules are optional; length matters most.

### 7) Transactions + audit logging consistency

You start a DB transaction for create/update, but your `_auditLogService.CreateAuditLogAsync()` probably uses a separate connection/transaction. That creates a consistency hole: user update might commit but audit fails (or audit commits but user rolls back). You partially handle rollback, but it won‚Äôt work if audit is not inside the same transaction.

**Best practice options:**

1. Make audit write use the same `conn` and `transaction`, or
2. Use an ‚Äúoutbox‚Äù table in the same transaction, then a background worker ships to audit table.

### 8) Controller security: hard-coded user IDs and missing authorization

`currentUserId = 1/2` is a security hole once you go live. You must fetch from authenticated identity/session, and enforce role-based access on endpoints like Create/Update/Manage. You already use `[ValidateAntiForgeryToken]` which is good for MVC forms, but authorization is the bigger gap here.

---

## A cleaned-up, safer version of your `UPDATE` method (core idea)

Below is a minimal ‚Äúsecure + race-safe‚Äù approach without changing your whole architecture. It enforces row_version, fixes the SQL, and removes trusting client for audit fields.

```csharp
public async Task<Result<bool>> UpdateUserAsync(UserUpdateDTO dto, int currentUserId)
{
    await using var conn = await _dataSource.OpenConnectionAsync();
    await using var tx = await conn.BeginTransactionAsync();

    try
    {
        // Read old data as simple types to avoid enum mapping surprises
        const string oldSql = @"
SELECT id, username, role, branch_id, is_active, is_locked, row_version, created_by, approved_by
FROM users WHERE id = @Id;";

        var old = await conn.QueryFirstOrDefaultAsync<dynamic>(oldSql, new { dto.Id }, tx);
        if (old == null) return Result<bool>.Failure("User not found.");

        // Authorization check should happen here (based on currentUserId role/claims)

        // Server-side validation (domain)
        var domain = AppUser.Create((string)old.username, "DUMMY_HASH_NOT_USED", Enum.Parse<UserRole>((string)old.role), (int)old.branch_id, (int)old.created_by);
        domain.UpdateGeneralInfo(dto.Username, dto.Role, dto.BranchId, dto.IsActive, dto.IsLocked, dto.RowVersion, currentUserId, DateTime.UtcNow);

        const string updateSql = @"
UPDATE users
SET
    username = @Username,
    role = @Role,
    branch_id = @BranchId,
    is_active = @IsActive,
    is_locked = @IsLocked,
    updated_by = @UpdatedBy,
    updated_at = @UpdatedAt,
    row_version = row_version + 1
WHERE id = @Id AND row_version = @ExpectedRowVersion;";

        var affected = await conn.ExecuteAsync(updateSql, new
        {
            Id = dto.Id,
            Username = domain.Username,
            Role = domain.Role.ToString(),
            BranchId = domain.BranchId,
            IsActive = domain.IsActive,
            IsLocked = domain.IsLocked,
            UpdatedBy = domain.UpdatedBy,
            UpdatedAt = domain.UpdatedAt,
            ExpectedRowVersion = dto.RowVersion
        }, tx);

        if (affected == 0)
        {
            await tx.RollbackAsync();
            return Result<bool>.Failure("Concurrency conflict: data was updated by someone else. Reload and try again.");
        }

        // Write audit log using SAME conn+tx (best), or outbox pattern
        // await _auditLogService.CreateAuditLogAsync(auditDto, conn, tx);

        await tx.CommitAsync();
        return Result<bool>.Success(true, "User updated successfully.");
    }
    catch
    {
        await tx.RollbackAsync();
        return Result<bool>.Failure("Database Error");
    }
}
```

---

## Recommended DB DDL upgrades (practical)

If you want the ‚Äúcleanest‚Äù approach long-term, I‚Äôd do two changes: store role as numeric, and enforce normalized username uniqueness. Example sketch:

```sql
ALTER TABLE users
  ADD COLUMN username_normalized VARCHAR(50) NOT NULL,
  ADD UNIQUE KEY uq_users_username_norm (username_normalized);

-- If you switch role to numeric:
ALTER TABLE users
  ADD COLUMN role_id TINYINT NOT NULL,
  DROP COLUMN role;

-- Add audit foreign keys (choose RESTRICT or SET NULL based on policy)
ALTER TABLE users
  ADD CONSTRAINT fk_users_created_by FOREIGN KEY (created_by) REFERENCES users(id),
  ADD CONSTRAINT fk_users_updated_by FOREIGN KEY (updated_by) REFERENCES users(id),
  ADD CONSTRAINT fk_users_approved_by FOREIGN KEY (approved_by) REFERENCES users(id);
```

Then in C# always write `username_normalized = dto.Username.Trim().ToUpperInvariant()`.

---

If you tell me one thing‚Äîare you willing to change the DB role from `ENUM` to `TINYINT` (matching your `UserRole` enum values)?‚ÄîI can give you the exact migration SQL + the exact Dapper mapping code in your current structure without redesigning the whole project.



##################################




‡¶†‡¶ø‡¶ï ‡¶Ü‡¶õ‡ßá‚Äî‡¶è‡¶ü‡¶æ ‡¶Ü‡¶Æ‡¶ø **‡¶™‡ßÅ‡¶∞‡ßã‡¶ü‡¶æ ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡ßü**, ‡¶è‡¶¨‡¶Ç **‡¶∏‡¶ø‡¶ï‡¶ø‡¶â‡¶∞‡¶ø‡¶ü‡¶ø + ‡¶¨‡ßá‡¶∏‡ßç‡¶ü ‡¶™‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï‡¶ü‡¶ø‡¶∏** ‡¶´‡ßã‡¶ï‡¶æ‡¶∏ ‡¶∞‡ßá‡¶ñ‡ßá ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶ï‡¶∞‡¶õ‡¶ø‡•§ ‡¶Ü‡¶Æ‡¶ø ‡¶ß‡¶æ‡¶™‡ßá ‡¶ß‡¶æ‡¶™‡ßá ‡¶¨‡¶≤‡¶¨‡ßã:
**(‡ßß) ‡¶°‡¶æ‡¶ü‡¶æ‡¶¨‡ßá‡¶∏**, **(‡ß®) ‡¶°‡ßã‡¶Æ‡ßá‡¶á‡¶®/‡¶è‡¶®‡¶ü‡¶ø‡¶ü‡¶ø**, **(‡ß©) ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶ø‡¶∏/‡¶°‡ßç‡¶Ø‡¶æ‡¶™‡¶æ‡¶∞**, **(‡ß™) DTO + ‡¶ï‡¶®‡ßç‡¶ü‡ßç‡¶∞‡ßã‡¶≤‡¶æ‡¶∞**, ‡¶è‡¶¨‡¶Ç ‡¶∂‡ßá‡¶∑‡ßá **‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™‡ßá ‡¶ï‡ßÄ ‡¶ï‡ßÄ ‡¶†‡¶ø‡¶ï ‡¶ï‡¶∞‡¶≤‡ßá ‡¶™‡ßç‡¶∞‡ßã‡¶°‡¶æ‡¶ï‡¶∂‡¶®-‡¶ó‡ßç‡¶∞‡ßá‡¶° ‡¶π‡¶¨‡ßá**‡•§

---

## ‡ßßÔ∏è‚É£ Database (`users` ‡¶ü‡ßá‡¶¨‡¶ø‡¶≤) ‚Äì ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶ì ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶®

### ‚ùå ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ‚Äì‡ßß: Username ‡¶á‡¶â‡¶®‡¶ø‡¶ï ‡¶π‡¶≤‡ßá‡¶ì ‡¶¨‡¶æ‡¶á‡¶™‡¶æ‡¶∏ ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü

‡¶Ü‡¶™‡¶®‡¶ø ‡¶ï‡ßã‡¶°‡ßá `Trim()` ‡¶ï‡¶∞‡¶õ‡ßá‡¶®, ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ ‡¶°‡¶æ‡¶ü‡¶æ‡¶¨‡ßá‡¶∏‡ßá:

* `User1`
* `user1`
* `USER1`

‡¶è‡¶ó‡ßÅ‡¶≤‡ßã ‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ ‡¶π‡¶ø‡¶∏‡ßá‡¶¨‡ßá ‡¶¢‡ßÅ‡¶ï‡ßá ‡¶Ø‡ßá‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá (collation ‡¶Ö‡¶®‡ßÅ‡¶Ø‡¶æ‡ßü‡ßÄ) ‚Üí **‡¶∏‡¶ø‡¶ï‡¶ø‡¶â‡¶∞‡¶ø‡¶ü‡¶ø ‡¶ì ‡¶°‡ßá‡¶ü‡¶æ ‡¶ï‡¶∞‡¶æ‡¶™‡¶∂‡¶® ‡¶∞‡¶ø‡¶∏‡ßç‡¶ï**‡•§

### ‚úÖ ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶® (Best Practice)

‡¶è‡¶ï‡¶ü‡¶ø **normalized username** ‡¶∞‡¶æ‡¶ñ‡ßÅ‡¶®‡•§

```sql
ALTER TABLE users 
ADD COLUMN username_normalized VARCHAR(50) NOT NULL,
ADD UNIQUE KEY uq_username_norm (username_normalized);
```

C# ‡¶è:

```csharp
username_normalized = username.Trim().ToUpperInvariant();
```

---

### ‚ùå ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ‚Äì‡ß®: `created_by / updated_by / approved_by` ‡¶ï‡ßã‡¶®‡ßã FK ‡¶®‡¶æ

‡¶è‡¶ó‡ßÅ‡¶≤‡ßã ‡¶Ö‡¶°‡¶ø‡¶ü‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶∏‡¶¨‡¶ö‡ßá‡ßü‡ßá ‡¶ó‡ßÅ‡¶∞‡ßÅ‡¶§‡ßç‡¶¨‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶´‡¶ø‡¶≤‡ßç‡¶°, ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ:

* ‡¶Ø‡ßá‡¶ï‡ßã‡¶®‡ßã ‡¶≠‡ßç‡¶Ø‡¶æ‡¶≤‡ßÅ ‡¶¢‡ßÅ‡¶ï‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá
* ‡¶Ø‡ßá‡¶á ‡¶á‡¶â‡¶ú‡¶æ‡¶∞ ‡¶®‡¶æ‡¶á, ‡¶§‡¶æ‡¶∞ ‡¶Ü‡¶á‡¶°‡¶ø ‡¶¢‡ßÅ‡¶ï‡ßá ‡¶Ø‡ßá‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá

### ‚úÖ ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶®

Self-referencing foreign key ‡¶¶‡¶ø‡¶®:

```sql
ALTER TABLE users
ADD CONSTRAINT fk_created_by FOREIGN KEY (created_by) REFERENCES users(id),
ADD CONSTRAINT fk_updated_by FOREIGN KEY (updated_by) REFERENCES users(id),
ADD CONSTRAINT fk_approved_by FOREIGN KEY (approved_by) REFERENCES users(id);
```

---

### ‚ùå ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ‚Äì‡ß©: `row_version` ‡¶•‡¶æ‡¶ï‡¶≤‡ßá‡¶ì DB ‡¶≤‡ßá‡¶≠‡ßá‡¶≤‡ßá ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡¶õ‡ßá ‡¶®‡¶æ

‡¶Ü‡¶™‡¶®‡¶ø `row_version` ‡¶¨‡¶æ‡ßú‡¶æ‡¶ö‡ßç‡¶õ‡ßá‡¶®, ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ **UPDATE-‡¶è ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡¶õ‡ßá‡¶® ‡¶®‡¶æ**‡•§

‡¶Æ‡¶æ‡¶®‡ßá:

* ‡¶¶‡ßÅ‡¶á‡¶ú‡¶® ‡¶è‡¶ï‡¶∏‡¶æ‡¶•‡ßá ‡¶è‡¶°‡¶ø‡¶ü ‡¶ï‡¶∞‡¶≤‡ßá
* ‡¶∂‡ßá‡¶∑ ‡¶ú‡¶® ‡¶Ü‡¶ó‡ßá‡¶∞ ‡¶ú‡¶®‡ßá‡¶∞ ‡¶°‡¶æ‡¶ü‡¶æ ‡¶ì‡¶≠‡¶æ‡¶∞‡¶∞‡¶æ‡¶á‡¶ü ‡¶ï‡¶∞‡ßá ‡¶¶‡ßá‡¶¨‡ßá
* ‡¶ï‡ßã‡¶®‡ßã error ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡¶¨‡ßá ‡¶®‡¶æ ‚ùå

### ‚úÖ ‡¶∏‡¶†‡¶ø‡¶ï ‡¶™‡ßç‡¶Ø‡¶æ‡¶ü‡¶æ‡¶∞‡ßç‡¶® (Optimistic Concurrency)

```sql
UPDATE users
SET 
    ..., 
    row_version = row_version + 1
WHERE id = @Id AND row_version = @ExpectedRowVersion;
```

`affectedRows == 0` ‡¶π‡¶≤‡ßá ‡¶¨‡ßÅ‡¶ù‡¶¨‡ßá‡¶®:

> ‚Äú‡¶è‡¶á ‡¶°‡¶æ‡¶ü‡¶æ ‡¶á‡¶§‡¶ø‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶Ö‡¶®‡ßç‡¶Ø ‡¶ï‡ßá‡¶â ‡¶Ü‡¶™‡¶°‡ßá‡¶ü ‡¶ï‡¶∞‡ßá‡¶õ‡ßá‚Äù

---

### ‚ö†Ô∏è ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ‚Äì‡ß™: `ENUM role`

`ENUM('Maker','Checker',...)` ‡¶õ‡ßã‡¶ü ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™‡ßá ‡¶†‡¶ø‡¶ï ‡¶Ü‡¶õ‡ßá, ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ:

* ‡¶≠‡¶¨‡¶ø‡¶∑‡ßç‡¶Ø‡¶§‡ßá role ‡¶¨‡¶¶‡¶≤‡¶æ‡¶®‡ßã ‡¶ï‡¶∑‡ßç‡¶ü‡¶ï‡¶∞
* Dapper + C# enum mapping ‡¶è ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡ßü

### ‚úÖ ‡¶¨‡ßá‡¶∏‡ßç‡¶ü ‡¶™‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï‡¶ü‡¶ø‡¶∏

`TINYINT` ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßÅ‡¶® (C# enum ‡¶è‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá 1:1 match ‡¶ï‡¶∞‡¶¨‡ßá)
‡¶Ö‡¶•‡¶¨‡¶æ ‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ `roles` ‡¶ü‡ßá‡¶¨‡¶ø‡¶≤‡•§

---

## ‡ß®Ô∏è‚É£ Domain Entity (`AppUser`) ‚Äì ‡¶ó‡ßÅ‡¶∞‡ßÅ‡¶§‡¶∞ ‡¶¨‡¶æ‡¶ó

### ‚ùå **Critical Bug**: ‡¶≠‡ßÅ‡¶≤ ‡¶≠‡ßç‡¶Ø‡¶æ‡¶∞‡¶ø‡ßü‡ßá‡¶¨‡¶≤ ‡¶ö‡ßá‡¶ï

```csharp
if (RowVersion <= 0) throw new Exception("RowVersion is missing");
```

‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶Ü‡¶™‡¶®‡¶ø **property** ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡¶õ‡ßá‡¶®,
‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡¶æ ‡¶â‡¶ö‡¶ø‡¶§ ‡¶õ‡¶ø‡¶≤ **parameter (`rowVersion`)**‡•§

### ‚ùå ‡¶Ü‡¶∞‡¶ì ‡¶¨‡ßú ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ

Concurrency check ‡¶®‡ßá‡¶á:

```csharp
if (currentRowVersion != RowVersion)
    throw new Exception("Concurrency conflict");
```

### ‚úÖ ‡¶∏‡¶†‡¶ø‡¶ï ‡¶∏‡¶Ç‡¶∏‡ßç‡¶ï‡¶∞‡¶£

```csharp
public void UpdateGeneralInfo(
    string username,
    UserRole role,
    int branchId,
    bool isActive,
    bool isLocked,
    int currentRowVersion,
    int updatedBy,
    DateTime nowUtc)
{
    if (currentRowVersion != RowVersion)
        throw new Exception("‡¶°‡¶æ‡¶ü‡¶æ ‡¶á‡¶§‡¶ø‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶π‡ßü‡ßá‡¶õ‡ßá");

    Username = ValidateUsername(username);
    Role = role;
    BranchId = branchId;
    IsActive = isActive;
    IsLocked = isLocked;

    RowVersion++;
    UpdatedBy = updatedBy;
    UpdatedAt = nowUtc;
}
```

---

## ‡ß©Ô∏è‚É£ Service Layer (`UserService`) ‚Äì Security & Logic Issues

### ‚ùå ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ‚Äì‡ßß: UPDATE SQL-‡¶è ‡¶¨‡ßú ‡¶≠‡ßÅ‡¶≤

```sql
role = Role,
```

‡¶è‡¶ü‡¶æ ‡¶π‡¶ì‡ßü‡¶æ ‡¶â‡¶ö‡¶ø‡¶§:

```sql
role = @Role,
```

‡¶è‡¶ü‡¶æ ‡¶®‡¶æ ‡¶π‡¶≤‡ßá MySQL ‡¶≠‡ßÅ‡¶≤‡¶≠‡¶æ‡¶¨‡ßá column/value ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶ï‡¶∞‡¶¨‡ßá‡•§

---

### ‚ùå ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ‚Äì‡ß®: Concurrency enforce ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡¶®‡¶ø

‡¶Ü‡¶™‡¶®‡¶ø ‡¶∂‡ßÅ‡¶ß‡ßÅ `row_version` ‡¶¨‡¶æ‡ßú‡¶æ‡¶ö‡ßç‡¶õ‡ßá‡¶®, ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ **WHERE-‡¶è ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡ßá‡¶®‡¶®‡¶ø**‡•§

### ‚úÖ ‡¶∏‡¶†‡¶ø‡¶ï UPDATE SQL

```sql
WHERE id = @Id AND row_version = @ExpectedRowVersion;
```

‡¶Ø‡¶¶‡¶ø `affectedRows == 0` ‚Üí concurrency error‡•§

---

### ‚ùå ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ‚Äì‡ß©: ENUM role + Dapper mapping

DB-‡¶§‡ßá role string (`"Maker"`),
C# ‡¶è `UserRole` int enum (`4`)
‚Üí Dapper ‡¶≠‡ßÅ‡¶≤ ‡¶Æ‡ßç‡¶Ø‡¶æ‡¶™ ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá‡•§

### ‚úÖ ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶®

* DB-‡¶§‡ßá numeric role ‡¶∞‡¶æ‡¶ñ‡ßÅ‡¶®
* ‡¶Ö‡¶•‡¶¨‡¶æ SELECT-‡¶è string ‡¶®‡¶ø‡¶®, ‡¶™‡¶∞‡ßá `Enum.Parse`

---

### ‚ö†Ô∏è ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ‚Äì‡ß™: Audit log ‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ transaction ‡¶è

User update rollback ‡¶π‡¶≤‡ßá‡¶ì audit insert ‡¶π‡ßü‡ßá ‡¶Ø‡ßá‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá (‡¶¨‡¶æ ‡¶â‡¶≤‡ßç‡¶ü‡ßã‡¶ü‡¶æ)‡•§

### ‚úÖ Best Practice

* ‡¶è‡¶ï‡¶á `DbConnection + Transaction` ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá audit ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶®
  ‡¶Ö‡¶•‡¶¨‡¶æ
* Outbox pattern ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßÅ‡¶®

---

## ‡ß™Ô∏è‚É£ DTO ‡¶ì Controller ‚Äì ‡¶®‡¶ø‡¶∞‡¶æ‡¶™‡¶§‡ßç‡¶§‡¶æ ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ

### ‚ùå ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ‚Äì‡ßß: UI ‡¶•‡ßá‡¶ï‡ßá Sensitive Field ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡ßã

`UserUpdateDTO` ‡¶§‡ßá ‡¶Ü‡¶õ‡ßá:

* `FailedAttempts`
* `IsLocked`
* `CreatedBy`
* `ApprovedBy`

‡¶è‡¶ó‡ßÅ‡¶≤‡ßã **‡¶á‡¶â‡¶ú‡¶æ‡¶∞ ‡¶á‡¶®‡¶™‡ßÅ‡¶ü ‡¶π‡¶ì‡ßü‡¶æ ‡¶â‡¶ö‡¶ø‡¶§ ‡¶®‡¶æ**‡•§

### ‚úÖ ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶®

* UI DTO ‡¶•‡ßá‡¶ï‡ßá ‡¶¨‡¶æ‡¶¶ ‡¶¶‡¶ø‡¶®
* ‡¶è‡¶ó‡ßÅ‡¶≤‡ßã ‡¶∂‡ßÅ‡¶ß‡ßÅ ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶ø‡¶∏/‡¶°‡ßã‡¶Æ‡ßá‡¶á‡¶® ‡¶®‡¶ø‡ßü‡¶®‡ßç‡¶§‡ßç‡¶∞‡¶£ ‡¶ï‡¶∞‡¶¨‡ßá

---

### ‚ùå ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ‚Äì‡ß®: Hardcoded `currentUserId`

```csharp
int currentUserId = 1;
```

‡¶è‡¶ü‡¶æ ‡¶™‡ßç‡¶∞‡ßã‡¶°‡¶æ‡¶ï‡¶∂‡¶®‡ßá **‡¶ó‡ßÅ‡¶∞‡ßÅ‡¶§‡¶∞ ‡¶∏‡¶ø‡¶ï‡¶ø‡¶â‡¶∞‡¶ø‡¶ü‡¶ø ‡¶π‡ßã‡¶≤**‡•§

### ‚úÖ ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶®

`User.Identity` ‡¶¨‡¶æ JWT/Session ‡¶•‡ßá‡¶ï‡ßá ‡¶®‡¶ø‡¶®
‡¶è‡¶¨‡¶Ç Role-based authorization ‡¶¶‡¶ø‡¶®‡•§

---

### ‚ùå ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ‚Äì‡ß©: Password validation ‡¶¶‡ßÅ‡¶∞‡ßç‡¶¨‡¶≤

Regex ‡¶¶‡¶ø‡ßü‡ßá strong password ‡¶¨‡ßç‡¶≤‡¶ï ‡¶ï‡¶∞‡¶õ‡ßá‡¶®‡•§

### ‚úÖ Best Practice

* ‡¶∂‡ßÅ‡¶ß‡ßÅ length enforce ‡¶ï‡¶∞‡ßÅ‡¶® (‚â•12)
* ‡¶Ø‡ßá‡¶ï‡ßã‡¶®‡ßã ‡¶ï‡ßç‡¶Ø‡¶æ‡¶∞‡ßá‡¶ï‡ßç‡¶ü‡¶æ‡¶∞ allow ‡¶ï‡¶∞‡ßÅ‡¶®
* BCrypt (‡¶Ü‡¶™‡¶®‡¶ø ‡¶†‡¶ø‡¶ï‡¶á ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá‡¶õ‡ßá‡¶® üëç)

---

### ‚ùå Bug: DTO constructor

```csharp
UserName = UserName;
```

‡¶è‡¶ü‡¶æ ‡¶≠‡ßÅ‡¶≤‡•§

### ‚úÖ ‡¶†‡¶ø‡¶ï ‡¶π‡¶¨‡ßá:

```csharp
UserName = userName;
```

---

## ‚úÖ ‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™‡ßá: Production-Ready ‡¶ï‡¶∞‡¶§‡ßá ‡¶Ø‡¶æ ‡¶ï‡¶∞‡¶¨‡ßá‡¶®

‚úî Username normalization + unique index
‚úî FK for audit fields
‚úî Optimistic concurrency (SQL + Domain)
‚úî ENUM ‚Üí numeric role
‚úî UTC time everywhere
‚úî Sensitive fields UI ‡¶•‡ßá‡¶ï‡ßá ‡¶¨‡¶æ‡¶¶
‚úî Same transaction-‡¶è audit log
‚úî Real authenticated userId
‚úî Authorization per role

---

‡¶Ü‡¶™‡¶®‡¶ø ‡¶ö‡¶æ‡¶á‡¶≤‡ßá ‡¶™‡¶∞‡ßá‡¶∞ ‡¶ß‡¶æ‡¶™‡ßá ‡¶Ü‡¶Æ‡¶ø:

* **‡¶™‡ßÅ‡¶∞‡ßã users table ‡¶è‡¶∞ corrected SQL**
* **Role ‚Üí TINYINT migration**
* **Perfect Dapper mapping**
* **Clean DTO split (Read vs Command)**
* **Login + lockout flow (secure)**

‡¶è‡¶á ‡¶™‡ßç‡¶∞‡¶ú‡ßá‡¶ï‡ßç‡¶ü‡¶ü‡¶æ ‡¶∏‡¶π‡¶ú‡ßá‡¶á **Bank-grade / Enterprise-grade** ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü‡•§
‡¶¨‡¶≤‡ßÅ‡¶®‚Äî**‡¶™‡¶∞‡ßá‡¶∞‡¶ü‡¶æ ‡¶ï‡ßã‡¶® ‡¶Ö‡¶Ç‡¶∂ ‡¶ö‡¶æ‡¶®?**
