Date: 8 January 2026

HoSuperAdmin: User create, Password Reset, Lock/Unloack, Active/Inactive for all branches.
BranchAdmin: Branch Users Lock/Unloack only, GL Posting permited(end of the day)
Checker: Customer Create, and Deposit/withdrawl posting as pending for customer
Maker:  User Lock/Unloack for his branch, and Deposit/withdrawl   posting-approver



→ Domain Layer
     → User Entities with role(Checker, Maker,BrAdmin,HoSuperAdmin), Business Logic for user and Audit_log

→ Application-Layer
    → Common global message, show success / failed
    → Services(password hash with bcrypt and reset, 3time wrong password lock user for 5minutes, duplicate user check)
    → Code for  Audit_Log
    → Interface and DTO for
         → Create
         → Update
         → Inactive
             • soft delete

→ Infrastructure-Layer
    → Implement of Interfaces from Application-Layer and Audit_Log
    → DB-conn.
    → EF installation(DB,Tools, PDF)

→ Presentation-Layer
    → ViewModel
    → UserController with CRUD and RBAC
    → Implement of Audit_Log
    → View
       → Create, Login
       → Show all (Update | Active | Inactive| Password Reset) → Search+Pagination
       → Update User, Password Reset


-----------------------------------------------

-- ১. এই টেবিলে ব্যাংকের প্রতিটি শাখার মৌলিক তথ্য এবং প্রধান ভল্টের ব্যালেন্স সংরক্ষিত থাকে।
-- এটি হেড অফিসকে প্রতিটি শাখার নগদ টাকার প্রবাহ (Liquidity) পর্যবেক্ষণ করতে সাহায্য করে।
-- সিস্টেমের প্রতিটি লেনদেন বা ইউজারের সাথে একটি নির্দিষ্ট শাখার আইডি যুক্ত করার জন্য এটি প্রধান রেফারেন্স।
CREATE TABLE branches (
    id INT AUTO_INCREMENT PRIMARY KEY,
    branch_code VARCHAR(10) UNIQUE NOT NULL,
    branch_name VARCHAR(100) NOT NULL,
    vault_balance DECIMAL(18, 2) DEFAULT 0.00,
    is_active BOOLEAN DEFAULT TRUE
);

-- ২. এখানে ব্যাংকের সকল কর্মকর্তাদের ইউজার আইডি, পাসওয়ার্ড এবং তাদের রোল (Role) সংরক্ষিত থাকে।
-- এটি নিশ্চিত করে যে শুধুমাত্র অনুমোদিত ইউজাররা নির্দিষ্ট শাখায় লগইন এবং লেনদেন করতে পারছেন।
-- সিকিউরিটি নিশ্চিত করতে ভুল লগইন এটেম্পট এবং অ্যাকাউন্ট লকিং সংক্রান্ত তথ্যও এখানে থাকে।
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    role ENUM('HoSuperAdmin', 'BrAdmin','Auditor', 'Maker', 'Checker') NOT NULL,
    branch_id INT NOT NULL,
    failed_attempts INT DEFAULT 0,
    lock_until TIMESTAMP NULL,
    is_locked BOOLEAN DEFAULT FALSE,
    is_active BOOLEAN DEFAULT TRUE,
    last_login TIMESTAMP NULL,
    FOREIGN KEY (branch_id) REFERENCES branches(id)
);



###########################################################################################################################

 Below is copy-paste ready Clean Architecture style using:

✅ Dapper + MySQL DataSource (`_dataSource.OpenConnectionAsync()`)
✅ BCrypt password hashing
✅ Audit Repository + Audit Service (CREATE / UPDATE / LOGIN_FAIL / LOCK / UNLOCK / LOGIN_SUCCESS)
✅ Lock user after 3 wrong password attempts (failed_attempts >= 3)

Folders:

- `CBS.Domain`
- `CBS.Application`
- `CBS.Infrastructure`
- `CBS.Web`

---


# 1) CBS.Domain

## 1.1 Result<T> (your global wrapper)

(Use your existing one)

## 1.2 Role Enum

`CBS.Domain/Enums/UserRole.cs`

```csharp
namespace CBS.Domain.Enums
{
    public enum UserRole
    {
        HoSuperAdmin,
        BrAdmin,
        Auditor,
        Maker,
        Checker
    }
}
```

## 1.3 User Entity (Domain rules + lock logic)

`CBS.Domain/Entities/AppUser.cs`

```csharp
using CBS.Domain.Common;
using CBS.Domain.Enums;

namespace CBS.Domain.Entities
{
    public class AppUser
    {
        public int Id { get; set; }
        public string Username { get; private set; } = string.Empty;
        public string PasswordHash { get; private set; } = string.Empty;
        public UserRole Role { get; private set; } = UserRole.Maker;
        public int BranchId { get; private set; }

        public int FailedAttempts { get; private set; } = 0;
        public DateTime? LockUntil { get; private set; }
        public bool IsLocked { get; private set; } = false;

        public bool IsActive { get; private set; } = true;
        public DateTime? LastLogin { get; private set; }

        // Create user with domain validation (single source of truth)
        public static AppUser Create(string username, string passwordHash, UserRole role, int branchId)
        {
            if (string.IsNullOrWhiteSpace(username)) throw new Exception("Username is required.");
            if (username.Length < 3 || username.Length > 50) throw new Exception("Username must be 3-50 characters.");
            if (string.IsNullOrWhiteSpace(passwordHash)) throw new Exception("Password hash is missing.");
            if (branchId <= 0) throw new Exception("BranchId is required.");

            return new AppUser
            {
                Username = username.Trim(),
                PasswordHash = passwordHash,
                Role = role,
                BranchId = branchId,
                FailedAttempts = 0,
                LockUntil = null,
                IsLocked = false,
                IsActive = true,
                LastLogin = null
            };
        }

        // Update general info; password hash optional
        public void UpdateGeneralInfo(string username, UserRole role, int branchId, bool isActive, string? newPasswordHash = null)
        {
            if (string.IsNullOrWhiteSpace(username)) throw new Exception("Username is required.");
            if (username.Length < 3 || username.Length > 50) throw new Exception("Username must be 3-50 characters.");
            if (branchId <= 0) throw new Exception("BranchId is required.");

            Username = username.Trim();
            Role = role;
            BranchId = branchId;
            IsActive = isActive;

            if (!string.IsNullOrWhiteSpace(newPasswordHash))
                PasswordHash = newPasswordHash;
        }

        // Called when password is wrong
        public void RegisterFailedLogin(int maxAttempts, TimeSpan lockDuration, DateTime nowUtc)
        {
            FailedAttempts += 1;

            // If reached max attempts => lock account
            if (FailedAttempts >= maxAttempts)
            {
                IsLocked = true;
                LockUntil = nowUtc.Add(lockDuration);
            }
        }

        // Called when login successful
        public void RegisterSuccessfulLogin(DateTime nowUtc)
        {
            FailedAttempts = 0;
            IsLocked = false;
            LockUntil = null;
            LastLogin = nowUtc;
        }

        // Unlock manually (admin)
        public void Unlock()
        {
            FailedAttempts = 0;
            IsLocked = false;
            LockUntil = null;
        }
    }
}
```

---

# 2) CBS.Application

## 2.1 DTOs

`CBS.Application/DTO/Users/UserDTOs.cs`

```csharp
using System.ComponentModel.DataAnnotations;
using CBS.Domain.Enums;

namespace CBS.Application.DTO.Users
{
    public record UserCreateDTO(
        [Required, StringLength(50, MinimumLength = 3)]
        string Username,

        [Required, StringLength(100, MinimumLength = 6)]
        string Password,

        [Required]
        UserRole Role,

        [Required, Range(1, int.MaxValue)]
        int BranchId
    );

    public record UserResponseDTO(
        int Id,
        string Username,
        UserRole Role,
        int BranchId,
        bool IsActive,
        bool IsLocked,
        int FailedAttempts,
        DateTime? LockUntil,
        DateTime? LastLogin
    );

    public class UserSearchDTO
    {
        public int Id { get; set; }
        public string Username { get; set; } = "";
        public UserRole Role { get; set; }
        public int BranchId { get; set; }
        public int FailedAttempts { get; set; }
        public DateTime? LockUntil { get; set; }
        public bool IsLocked { get; set; }
        public bool IsActive { get; set; }
        public DateTime? LastLogin { get; set; }
    }

    public record UserUpdateDTO(
        [Required] int Id,
        [Required, StringLength(50, MinimumLength = 3)] string Username,
        [Required] UserRole Role,
        [Required, Range(1, int.MaxValue)] int BranchId,
        [Required] bool IsActive,

        // optional password reset by admin
        [StringLength(100, MinimumLength = 6)] string? NewPassword
    );

    // Login input
    public record UserLoginDTO(
        [Required] string Username,
        [Required] string Password
    );

    // Login output
    public record LoginResultDTO(
        int UserId,
        string Username,
        UserRole Role,
        int BranchId,
        bool IsLocked,
        DateTime? LockUntil,
        string Message
    );
}
```

---

## 2.2 Audit DTO + Interfaces


## 2.3 User service interface

`CBS.Application/Interfaces/IUserService.cs`

```csharp
using CBS.Application.DTO.Users;
using CBS.Domain.Common;

namespace CBS.Application.Interfaces
{
    public interface IUserService
    {
        Task<Result<UserResponseDTO>> CreateUserAsync(UserCreateDTO dto, int currentUserId);
        Task<Result<UserSearchDTO>> GetByUsernameAsync(string username, int currentUserId);
        Task<Result<bool>> UpdateUserAsync(UserUpdateDTO dto, int currentUserId);

        // Login will enforce lock after 3 wrong attempts
        Task<Result<LoginResultDTO>> LoginAsync(UserLoginDTO dto);
    }
}
```

---

# 3) CBS.Infrastructure (Dapper + MySQL)

## 3.1 DataSource interface (if you already have, keep yours)

`CBS.Infrastructure/Persistence/IDataSource.cs`

```csharp
using MySqlConnector;

namespace CBS.Infrastructure.Persistence
{
    public interface IDataSource
    {
        Task<MySqlConnection> OpenConnectionAsync();
    }
}
```

> You already have something similar. Use your existing one.

---

## 3.2 Audit Repository (Dapper)
## 3.3 Audit Service


---

## 3.4 UserService (Create + Update + Login lock after 3 wrong)

`CBS.Infrastructure/Services/UserService.cs`

```csharp
using CBS.Application.DTO.Audit;
using CBS.Application.DTO.Users;
using CBS.Application.Interfaces;
using CBS.Domain.Common;
using CBS.Domain.Entities;
using CBS.Domain.Enums;
using CBS.Infrastructure.Persistence;
using Dapper;

namespace CBS.Infrastructure.Services
{
    public class UserService : IUserService
    {
        private readonly IDataSource _dataSource;
        private readonly IAuditLogService _audit;

        // Login policy
        private const int MAX_WRONG_ATTEMPTS = 3;
        private static readonly TimeSpan LOCK_DURATION = TimeSpan.FromMinutes(15);

        public UserService(IDataSource dataSource, IAuditLogService audit)
        {
            _dataSource = dataSource;
            _audit = audit;
        }

        public async Task<Result<UserResponseDTO>> CreateUserAsync(UserCreateDTO dto, int currentUserId)
        {
            using var conn = await _dataSource.OpenConnectionAsync();
            using var tx = await conn.BeginTransactionAsync();

            try
            {
                // 1) Duplicate username check
                const string dupSql = "SELECT COUNT(1) FROM users WHERE username = @Username;";
                int exists = await conn.ExecuteScalarAsync<int>(dupSql, new { Username = dto.Username.Trim() }, tx);
                if (exists > 0)
                    return Result<UserResponseDTO>.Failure("Username already exists.");

                // 2) Hash password using BCrypt
                string hash = BCrypt.Net.BCrypt.HashPassword(dto.Password);

                // 3) Domain entity creation (business validation in one place)
                AppUser user;
                try
                {
                    user = AppUser.Create(dto.Username, hash, dto.Role, dto.BranchId);
                }
                catch (Exception ex)
                {
                    return Result<UserResponseDTO>.Failure(ex.Message);
                }

                // 4) Insert user
                const string insertSql = @"
                                        INSERT INTO users (username, password_hash, role, branch_id, failed_attempts, lock_until, is_locked, is_active, last_login)
                                        VALUES (@Username, @PasswordHash, @Role, @BranchId, @FailedAttempts, @LockUntil, @IsLocked, @IsActive, @LastLogin);
                                        SELECT LAST_INSERT_ID();";

                int newId = await conn.ExecuteScalarAsync<int>(insertSql, new
                {
                    Username = user.Username,
                    PasswordHash = user.PasswordHash,
                    Role = user.Role.ToString(), // store enum as string matching DB enum
                    BranchId = user.BranchId,
                    FailedAttempts = user.FailedAttempts,
                    LockUntil = user.LockUntil,
                    IsLocked = user.IsLocked,
                    IsActive = user.IsActive,
                    LastLogin = user.LastLogin
                }, tx);

                if (newId <= 0)
                {
                    await tx.RollbackAsync();
                    return Result<UserResponseDTO>.Failure("Failed! User not created.");
                }

                // 5) Audit log inside same transaction behaviour (if you want strict consistency)
                var auditDto = new AuditLogCreateDTO(
                    TableName: "users",
                    Action: "CREATE",
                    KeyValue: $"id={newId}",
                    OldValue: "-",
                    NewValue: $"Username:{user.Username}, Role:{user.Role}, BranchId:{user.BranchId}, Active:{user.IsActive}",
                    Description: "New user created",
                    CreatedBy: currentUserId
                );

                var auditRes = await _audit.CreateAuditLogAsync(auditDto);
                if (!auditRes.IsSuccess)
                {
                    await tx.RollbackAsync();
                    return Result<UserResponseDTO>.Failure("Audit log failed. Transaction rolled back.");
                }

                await tx.CommitAsync();

                var response = new UserResponseDTO(
                    Id: newId,
                    Username: user.Username,
                    Role: user.Role,
                    BranchId: user.BranchId,
                    IsActive: user.IsActive,
                    IsLocked: user.IsLocked,
                    FailedAttempts: user.FailedAttempts,
                    LockUntil: user.LockUntil,
                    LastLogin: user.LastLogin
                );

                return Result<UserResponseDTO>.Success(response, "User created successfully.");
            }
            catch (Exception ex)
            {
                await tx.RollbackAsync();
                return Result<UserResponseDTO>.Failure("Database Error: " + ex.Message);
            }
        }

        public async Task<Result<UserSearchDTO>> GetByUsernameAsync(string username, int currentUserId)
        {
            using var conn = await _dataSource.OpenConnectionAsync();
            using var tx = await conn.BeginTransactionAsync();

            try
            {
                const string sql = @"
                                   SELECT
                                     id AS Id,
                                     username AS Username,
                                     role AS Role,
                                     branch_id AS BranchId,
                                     failed_attempts AS FailedAttempts,
                                     lock_until AS LockUntil,
                                     is_locked AS IsLocked,
                                     is_active AS IsActive,
                                     last_login AS LastLogin
                                   FROM users
                                   WHERE username = @Username;";

                var user = await conn.QueryFirstOrDefaultAsync<UserSearchDTO>(sql, new { Username = username.Trim() }, tx);
                if (user == null)
                    return Result<UserSearchDTO>.Failure("User not found.");

                // Convert Role string -> enum (Dapper maps string to enum if property type is enum usually; if not, you can do manual)
                // If needed, change Role in DTO to string.

                // Audit READ
                var auditDto = new AuditLogCreateDTO(
                    TableName: "users",
                    Action: "READ",
                    KeyValue: $"username={user.Username}",
                    OldValue: "-",
                    NewValue: $"Viewed user profile: {user.Username}",
                    Description: "User searched by username",
                    CreatedBy: currentUserId
                );

                var auditRes = await _audit.CreateAuditLogAsync(auditDto);
                if (!auditRes.IsSuccess)
                {
                    await tx.RollbackAsync();
                    return Result<UserSearchDTO>.Failure("Audit log failed. Transaction rolled back.");
                }

                await tx.CommitAsync();
                return Result<UserSearchDTO>.Success(user);
            }
            catch (Exception ex)
            {
                await tx.RollbackAsync();
                return Result<UserSearchDTO>.Failure("Database Error: " + ex.Message);
            }
        }

        public async Task<Result<bool>> UpdateUserAsync(UserUpdateDTO dto, int currentUserId)
        {
            using var conn = await _dataSource.OpenConnectionAsync();
            using var tx = await conn.BeginTransactionAsync();

            try
            {
                // 1) Load current user for old values + domain updates
                const string selectSql = @"
                                        SELECT
                                          id AS Id,
                                          username AS Username,
                                          password_hash AS PasswordHash,
                                          role AS Role,
                                          branch_id AS BranchId,
                                          failed_attempts AS FailedAttempts,
                                          lock_until AS LockUntil,
                                          is_locked AS IsLocked,
                                          is_active AS IsActive,
                                          last_login AS LastLogin
                                        FROM users
                                        WHERE id = @Id;";

                // Using Domain entity to reuse logic
                var user = await conn.QueryFirstOrDefaultAsync<AppUserRow>(selectSql, new { dto.Id }, tx);
                if (user == null)
                    return Result<bool>.Failure("User not found.");

                // old data for audit
                string oldData = $"Username:{user.Username}, Role:{user.Role}, BranchId:{user.BranchId}, Active:{user.IsActive}, Locked:{user.IsLocked}, Failed:{user.FailedAttempts}";

                // 2) Duplicate username check (if changed)
                const string dupSql = "SELECT COUNT(1) FROM users WHERE username=@Username AND id<>@Id;";
                int dup = await conn.ExecuteScalarAsync<int>(dupSql, new { Username = dto.Username.Trim(), Id = dto.Id }, tx);
                if (dup > 0)
                    return Result<bool>.Failure("Username already exists.");

                // 3) Build new password hash if provided
                string? newHash = null;
                if (!string.IsNullOrWhiteSpace(dto.NewPassword))
                    newHash = BCrypt.Net.BCrypt.HashPassword(dto.NewPassword);

                // 4) Domain-like validation (simple here)
                if (dto.BranchId <= 0) return Result<bool>.Failure("BranchId is required.");

                // 5) Update DB
                const string updateSql = @"
                                        UPDATE users
                                        SET
                                          username = @Username,
                                          password_hash = @PasswordHash,
                                          role = @Role,
                                          branch_id = @BranchId,
                                          is_active = @IsActive
                                        WHERE id = @Id;";

                string finalHash = newHash ?? user.PasswordHash;

                int affected = await conn.ExecuteAsync(updateSql, new
                {
                    Id = dto.Id,
                    Username = dto.Username.Trim(),
                    PasswordHash = finalHash,
                    Role = dto.Role.ToString(),
                    BranchId = dto.BranchId,
                    IsActive = dto.IsActive
                }, tx);

                if (affected <= 0)
                {
                    await tx.RollbackAsync();
                    return Result<bool>.Failure("Update failed.");
                }

                // 6) Audit UPDATE
                string newData = $"Username:{dto.Username.Trim()}, Role:{dto.Role}, BranchId:{dto.BranchId}, Active:{dto.IsActive}";
                var auditDto = new AuditLogCreateDTO(
                    TableName: "users",
                    Action: "UPDATE",
                    KeyValue: $"id={dto.Id}",
                    OldValue: oldData,
                    NewValue: newData,
                    Description: "User updated",
                    CreatedBy: currentUserId
                );

                var auditRes = await _audit.CreateAuditLogAsync(auditDto);
                if (!auditRes.IsSuccess)
                {
                    await tx.RollbackAsync();
                    return Result<bool>.Failure("Audit log failed. Transaction rolled back.");
                }

                await tx.CommitAsync();
                return Result<bool>.Success(true, "User updated successfully.");
            }
            catch (Exception ex)
            {
                await tx.RollbackAsync();
                return Result<bool>.Failure("Database Error: " + ex.Message);
            }
        }

        // -----------------------------
        // LOGIN + 3 wrong attempts lock
        // -----------------------------
        public async Task<Result<LoginResultDTO>> LoginAsync(UserLoginDTO dto)
        {
            using var conn = await _dataSource.OpenConnectionAsync();
            using var tx = await conn.BeginTransactionAsync();

            try
            {
                // 1) Load user by username
                const string sql = @"
                                   SELECT
                                     id AS Id,
                                     username AS Username,
                                     password_hash AS PasswordHash,
                                     role AS Role,
                                     branch_id AS BranchId,
                                     failed_attempts AS FailedAttempts,
                                     lock_until AS LockUntil,
                                     is_locked AS IsLocked,
                                     is_active AS IsActive,
                                     last_login AS LastLogin
                                   FROM users
                                   WHERE username = @Username;";

                var user = await conn.QueryFirstOrDefaultAsync<AppUserRow>(sql, new { Username = dto.Username.Trim() }, tx);

                if (user == null)
                {
                    // Do NOT reveal if username exists (security)
                    return Result<LoginResultDTO>.Failure("Invalid username or password.");
                }

                // 2) If inactive => stop
                if (!user.IsActive)
                    return Result<LoginResultDTO>.Failure("Account is inactive.");

                // 3) If locked and lock_until in future => stop
                var nowUtc = DateTime.UtcNow;
                if (user.IsLocked && user.LockUntil.HasValue && user.LockUntil.Value > nowUtc)
                {
                    return Result<LoginResultDTO>.Failure($"Account locked until {user.LockUntil.Value:u}");
                }

                // 4) Verify password using BCrypt
                bool ok = BCrypt.Net.BCrypt.Verify(dto.Password, user.PasswordHash);

                if (!ok)
                {
                    // WRONG password => increment attempts and maybe lock
                    int newFailed = user.FailedAttempts + 1;

                    bool willLock = newFailed >= MAX_WRONG_ATTEMPTS;
                    DateTime? newLockUntil = willLock ? nowUtc.Add(LOCK_DURATION) : user.LockUntil;

                    const string updateFailSql = @"
                                                  UPDATE users
                                                  SET
                                                    failed_attempts = @FailedAttempts,
                                                    is_locked = @IsLocked,
                                                    lock_until = @LockUntil
                                                  WHERE id = @Id;";

                    await conn.ExecuteAsync(updateFailSql, new
                    {
                        Id = user.Id,
                        FailedAttempts = newFailed,
                        IsLocked = willLock,
                        LockUntil = newLockUntil
                    }, tx);

                    // Audit LOGIN_FAIL
                    await _audit.CreateAuditLogAsync(new AuditLogCreateDTO(
                        TableName: "users",
                        Action: "LOGIN_FAIL",
                        KeyValue: $"id={user.Id}",
                        OldValue: $"FailedAttempts:{user.FailedAttempts}, Locked:{user.IsLocked}, LockUntil:{user.LockUntil}",
                        NewValue: $"FailedAttempts:{newFailed}, Locked:{willLock}, LockUntil:{newLockUntil}",
                        Description: willLock ? "Wrong password. Account locked (3 attempts)." : "Wrong password attempt.",
                        CreatedBy: user.Id
                    ));

                    await tx.CommitAsync();

                    // Return generic message
                    if (willLock)
                        return Result<LoginResultDTO>.Failure("Account locked due to 3 wrong password attempts.");

                    return Result<LoginResultDTO>.Failure("Invalid username or password.");
                }

                // 5) Password OK => reset failed attempts + unlock + update last login
                const string updateSuccessSql = @"
                                                  UPDATE users
                                                  SET
                                                    failed_attempts = 0,
                                                    is_locked = FALSE,
                                                    lock_until = NULL,
                                                    last_login = @LastLogin
                                                  WHERE id = @Id;";

                await conn.ExecuteAsync(updateSuccessSql, new
                {
                    Id = user.Id,
                    LastLogin = nowUtc
                }, tx);

                // Audit LOGIN_SUCCESS
                await _audit.CreateAuditLogAsync(new AuditLogCreateDTO(
                    TableName: "users",
                    Action: "LOGIN_SUCCESS",
                    KeyValue: $"id={user.Id}",
                    OldValue: "-",
                    NewValue: $"LastLogin:{nowUtc:u}",
                    Description: "User logged in successfully",
                    CreatedBy: user.Id
                ));

                await tx.CommitAsync();

                // build response
                var roleEnum = Enum.Parse<UserRole>(user.Role);
                var response = new LoginResultDTO(
                    UserId: user.Id,
                    Username: user.Username,
                    Role: roleEnum,
                    BranchId: user.BranchId,
                    IsLocked: false,
                    LockUntil: null,
                    Message: "Login successful."
                );

                return Result<LoginResultDTO>.Success(response, "Login successful.");
            }
            catch (Exception ex)
            {
                await tx.RollbackAsync();
                return Result<LoginResultDTO>.Failure("Database Error: " + ex.Message);
            }
        }

        // Helper row model for Dapper mapping (since AppUser uses private setters + enum)
        private class AppUserRow
        {
            public int Id { get; set; }
            public string Username { get; set; } = "";
            public string PasswordHash { get; set; } = "";
            public string Role { get; set; } = "Maker";
            public int BranchId { get; set; }
            public int FailedAttempts { get; set; }
            public DateTime? LockUntil { get; set; }
            public bool IsLocked { get; set; }
            public bool IsActive { get; set; }
            public DateTime? LastLogin { get; set; }
        }
    }
}
```

---

# 4) CBS.Web (MVC Controller + Views)

## 4.1 Controller

`CBS.Web/Controllers/UserController.cs`

```csharp
using CBS.Application.DTO.Users;
using CBS.Application.Interfaces;
using CBS.Domain.Enums;
using Microsoft.AspNetCore.Mvc;

namespace CBS.Web.Controllers
{
    public class UserController : Controller
    {
        private readonly IUserService _service;

        public UserController(IUserService service)
        {
            _service = service;
        }

        // -------------------------
        // CREATE
        // -------------------------
        [HttpGet]
        public IActionResult Index()
            => View(new UserCreateDTO("", "", UserRole.Maker, 0));

        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> Create(UserCreateDTO dto)
        {
            if (!ModelState.IsValid) return View("Index", dto);

            int currentUserId = 1; // TODO: get from session/auth
            var result = await _service.CreateUserAsync(dto, currentUserId);

            if (result.IsSuccess)
            {
                TempData["Success"] = $"{result.Message} | ID:{result.Data.Id} | Username:{result.Data.Username}";
                return RedirectToAction(nameof(Index));
            }

            TempData["Error"] = result.Message;
            return View("Index", dto);
        }

        // -------------------------
        // MANAGE (Search) + UPDATE
        // -------------------------
        [HttpGet]
        public async Task<IActionResult> Manage(string? username)
        {
            if (string.IsNullOrWhiteSpace(username))
            {
                ViewData["Error"] = "Username cannot be empty.";
                return View();
            }

            int currentUserId = 2;
            var result = await _service.GetByUsernameAsync(username, currentUserId);
            if (!result.IsSuccess)
            {
                ViewData["Error"] = result.Message;
                return View();
            }

            var model = new UserUpdateDTO(
                Id: result.Data.Id,
                Username: result.Data.Username,
                Role: result.Data.Role,
                BranchId: result.Data.BranchId,
                IsActive: result.Data.IsActive,
                NewPassword: null
            );

            return View(model);
        }

        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> Update(UserUpdateDTO dto)
        {
            if (!ModelState.IsValid) return View("Manage", dto);

            int currentUserId = 3;
            var result = await _service.UpdateUserAsync(dto, currentUserId);

            if (result.IsSuccess)
            {
                TempData["Success"] = result.Message;
                return RedirectToAction("Manage", new { username = dto.Username });
            }

            TempData["Error"] = result.Message;
            return View("Manage", dto);
        }

// --------------------------------------
        // LOGIN (lock after 3 wrong)
// --------------------------------------
        [HttpGet]
        public IActionResult Login()
            => View(new UserLoginDTO("", ""));

        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> Login(UserLoginDTO dto)
        {
            if (!ModelState.IsValid) return View(dto);

            var result = await _service.LoginAsync(dto);
            if (result.IsSuccess)
            {
                TempData["Success"] = result.Message;
                // TODO: set session/cookie
                return RedirectToAction("Index");
            }

            TempData["Error"] = result.Message;
            return View(dto);
        }
    }
}
```

---

## 4.2 Views

### Create View: `Views/User/Index.cshtml`

```cshtml
@using CBS.Domain.Enums
@model CBS.Application.DTO.Users.UserCreateDTO

<div class="container mt-5">
  <div class="col-md-6 mx-auto">

    @if (TempData["Success"] != null) { <div class="alert alert-success">@TempData["Success"]</div> }
    @if (TempData["Error"] != null) { <div class="alert alert-danger">@TempData["Error"]</div> }

    <div class="card shadow">
      <div class="card-header bg-primary text-white">Create New User</div>
      <div class="card-body">

        <div asp-validation-summary="ModelOnly" class="text-danger small mb-3"></div>

        <form asp-action="Create" method="post">
          @Html.AntiForgeryToken()

          <div class="mb-3">
            <label asp-for="Username" class="form-label"></label>
            <input asp-for="Username" class="form-control" />
            <span asp-validation-for="Username" class="text-danger small"></span>
          </div>

          <div class="mb-3">
            <label asp-for="Password" class="form-label"></label>
            <input asp-for="Password" type="password" class="form-control" />
            <span asp-validation-for="Password" class="text-danger small"></span>
          </div>

          <div class="mb-3">
            <label asp-for="Role" class="form-label"></label>
            <select asp-for="Role" class="form-select">
              <option value="@UserRole.HoSuperAdmin">HoSuperAdmin</option>
              <option value="@UserRole.BrAdmin">BrAdmin</option>
              <option value="@UserRole.Auditor">Auditor</option>
              <option value="@UserRole.Maker">Maker</option>
              <option value="@UserRole.Checker">Checker</option>
            </select>
          </div>

          <div class="mb-3">
            <label asp-for="BranchId" class="form-label"></label>
            <input asp-for="BranchId" type="number" class="form-control" />
            <span asp-validation-for="BranchId" class="text-danger small"></span>
          </div>

          <button class="btn btn-success w-100" type="submit">Save</button>
        </form>
      </div>
      <div class="card-footer text-center">
        <a asp-action="Manage">Manage User</a> | <a asp-action="Login">Login</a>
      </div>
    </div>
  </div>
</div>

@section Scripts { <partial name="_ValidationScriptsPartial" /> }
```

### Manage/Update View: `Views/User/Manage.cshtml`

```cshtml
@using CBS.Domain.Enums
@model CBS.Application.DTO.Users.UserUpdateDTO

<div class="container mt-4">

  <div class="card mb-3">
    <div class="card-body">
      <form method="get" asp-action="Manage" class="row g-2">
        <div class="col-md-9">
          <input type="text" name="username" class="form-control" placeholder="Search username" />
        </div>
        <div class="col-md-3">
          <button class="btn btn-primary w-100">Search</button>
        </div>
      </form>
      @if (ViewData["Error"] != null) { <div class="text-danger mt-2">@ViewData["Error"]</div> }
    </div>
  </div>

  @if (TempData["Success"] != null) { <div class="alert alert-success">@TempData["Success"]</div> }
  @if (TempData["Error"] != null) { <div class="alert alert-danger">@TempData["Error"]</div> }

  @if (Model != null)
  {
    <div class="card shadow">
      <div class="card-header bg-dark text-white">Edit User: @Model.Username</div>
      <div class="card-body">
        <form asp-action="Update" method="post">
          @Html.AntiForgeryToken()
          <input type="hidden" asp-for="Id" />

          <div class="mb-3">
            <label asp-for="Username" class="form-label"></label>
            <input asp-for="Username" class="form-control" />
            <span asp-validation-for="Username" class="text-danger small"></span>
          </div>

          <div class="mb-3">
            <label asp-for="Role" class="form-label"></label>
            <select asp-for="Role" class="form-select">
              <option value="@UserRole.HoSuperAdmin">HoSuperAdmin</option>
              <option value="@UserRole.BrAdmin">BrAdmin</option>
              <option value="@UserRole.Auditor">Auditor</option>
              <option value="@UserRole.Maker">Maker</option>
              <option value="@UserRole.Checker">Checker</option>
            </select>
          </div>

          <div class="mb-3">
            <label asp-for="BranchId" class="form-label"></label>
            <input asp-for="BranchId" type="number" class="form-control" />
          </div>

          <div class="mb-3">
            <label asp-for="IsActive" class="form-label"></label>
            <select asp-for="IsActive" class="form-select">
              <option value="true">Active</option>
              <option value="false">Inactive</option>
            </select>
          </div>

          <div class="mb-3">
            <label asp-for="NewPassword" class="form-label">New Password (optional)</label>
            <input asp-for="NewPassword" type="password" class="form-control" />
            <span asp-validation-for="NewPassword" class="text-danger small"></span>
          </div>

          <button class="btn btn-success">Save Changes</button>
        </form>
      </div>
    </div>
  }
</div>

@section Scripts { <partial name="_ValidationScriptsPartial" /> }
```

### Login View: `Views/User/Login.cshtml`

```cshtml
@model CBS.Application.DTO.Users.UserLoginDTO

<div class="container mt-5">
  <div class="col-md-5 mx-auto">

    @if (TempData["Success"] != null) { <div class="alert alert-success">@TempData["Success"]</div> }
    @if (TempData["Error"] != null) { <div class="alert alert-danger">@TempData["Error"]</div> }

    <div class="card shadow">
      <div class="card-header bg-primary text-white">Login</div>
      <div class="card-body">
        <div asp-validation-summary="ModelOnly" class="text-danger small mb-3"></div>

        <form asp-action="Login" method="post">
          @Html.AntiForgeryToken()

          <div class="mb-3">
            <label asp-for="Username" class="form-label"></label>
            <input asp-for="Username" class="form-control" />
            <span asp-validation-for="Username" class="text-danger small"></span>
          </div>

          <div class="mb-3">
            <label asp-for="Password" class="form-label"></label>
            <input asp-for="Password" type="password" class="form-control" />
            <span asp-validation-for="Password" class="text-danger small"></span>
          </div>

          <button class="btn btn-success w-100">Login</button>
        </form>
      </div>
    </div>

  </div>
</div>

@section Scripts { <partial name="_ValidationScriptsPartial" /> }
```

---

# 5) Dependency Injection (Infrastructure)

Register repositories/services in `CBS.Web/Program.cs` (or your DI extension):

```csharp
builder.Services.AddScoped<IAuditLogRepository, AuditLogRepository>();
builder.Services.AddScoped<IAuditLogService, AuditLogService>();
builder.Services.AddScoped<IUserService, UserService>();
```

---

# 6) What you now have (English explanation)

- CreateUserAsync

  - Checks duplicate username
  - Hashes password using BCrypt
  - Inserts into `users`
  - Writes audit log CREATE

- UpdateUserAsync

  - Loads current user
  - Prevents duplicate username
  - Optionally re-hashes password if `NewPassword` provided
  - Updates DB
  - Writes audit log UPDATE

- LoginAsync (3 wrong attempts lock)

  - If password wrong → increments `failed_attempts`
  - On 3rd wrong → sets `is_locked = true`, `lock_until = now+15min`
  - Writes audit log LOGIN_FAIL and LOCK info in NewValue
  - If password correct → resets failed attempts, unlocks, sets `last_login`
  - Writes audit log LOGIN_SUCCESS

---

If you want, I can also add:

- Unlock endpoint (admin) with audit UNLOCK
- Checker/Maker approval pattern (like branch approved_by)
- BranchId dropdown from `branches` table (instead of typing ID)



.
