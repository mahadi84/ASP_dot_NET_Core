
Why this module first?
This module's Database Table's Relationship is not dependent to any..


##########################################
     -Entities
     -Global Carrier (Success/Faialur)
     -DTO  (AuditLogCreateDTO(), AuditReportFilterDTO(),AuditReportViewDTO())
     -Interface (Return type-Result<bool>, PagedResult<IEnumerable<T>> and DTO as parameter)   
     -Interface's Implementation
                -use db_connection, Dapper query, Transaction(Begain,RollBack,Commit) 
                -check duplicate
                -Insert Data
     -Use of Interface(in Web->Controller(User Request & Response))
     -View(Include DTO) 
##########################################


RETURN TYPE: 
------------
PagedResult<IEnumerable<T>>,  What does it in Pagination?
PagedResult: এটি একটি Valiable Container) বা ক্লাস। এটি শুধু আসল ডেটাগুলোই বহন করে না, বরং পেজিং সংক্রান্ত তথ্যও (যেমন: মোট কয়টি পেজ আছে, বর্তমান পেজ নম্বর কত) সাথে রাখে।
<IEnumerable<T>>: এটি একটি ইন্টারফেস যা নির্দেশ করে যে এর ভেতর একগুচ্ছ ডেটার তালিকা (List/Collection) আছে। T মানে হচ্ছে যেকোনো ধরনের অবজেক্ট (যেমন: User, Product ইত্যাদি)।
----
Task<IActionResult>:
দুটি জিনিসের সংমিশ্রণ: Task (অ্যাসিঙ্ক্রোনাস প্রোগ্রামিং) এবং IActionResult (HTTP রেসপন্স)।
IActionResult আপনাকে এই নমনীয়তা (Flexibility) দেয় যাতে আপনি একই মেথড থেকে বিভিন্ন ধরণের আউটপুট দিতে পারেন।
      -Ok() (HTTP 200)          //যদি ডেটা পাওয়া যায়, তবে আপনি Success (200 OK) পাঠাবেন।
      -NotFound() (HTTP 404)    //যদি ডেটা না পাওয়া যায়, তবে আপনি Not Found (404) পাঠাবেন।
      -BadRequest() (HTTP 400)
      View() (HTML পেজ দেখানোর জন্য)
      
      
----

SPECIAL QUERY:
---------------
  var sqlBody = new StringBuilder(@"
  FROM audit_logs al
  LEFT JOIN branches b ON al.branch_code = b.branch_code
  WHERE 1=1 ");
 
var parameters = new DynamicParameters();  // DynamicParameters(), এটি একটি ডাইনামিক ব্যাগ বা কন্টেইনারের মতো কাজ করে, যেখানে আপনি ডেটাবেস কোয়েরির জন্য প্রয়োজনীয় বিভিন্ন Parameters (প্যারামিটার) জমা রাখতে পারেন।
 
if (filter.FromDate.HasValue && filter.ToDate.HasValue) {     
     sqlBody.Append(" AND DATE(al.created_at) BETWEEN DATE(@FromDate) AND DATE(@ToDate) "); // তারিখের ফরম্যাট MySQL এর সাথে মেলানোর জন্য
     parameters.Add("FromDate", filter.FromDate);
     parameters.Add("ToDate", filter.ToDate);
 }

string countSql = $"SELECT COUNT(*) {sqlBody}";
int totalRecords = await connection.ExecuteScalarAsync<int>(countSql, parameters);


#############################################################################





→ Domain Layer
     → Branch Entities with Business Logic for user and Audit_log

→ Application-Layer
    → Common global message, show success / failed
    → Add  Audit_Log
    → Interface and DTO for
         → Create
         → Update
         → Inactive
             • soft delete

→ Infrastructure-Layer
    → Implement of Interfaces from Application-Layer and Audit_Log
    → DB-conn.
    → EF installation(DB,Tools, PDF)

→ Presentation-Layer
    → ViewModel
    → BranchController with CRUD and RBAC
    → Implement of Audit_Log
    → View
       → Create, Login
       → Show all (Update | Active | Inactive) → Search+Pagination
       → Update Branch info


----




CREATE TABLE audit_logs (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    branch_code INT NOT NULL,
    user_id INT NOT NULL,
    table_name VARCHAR(100) NOT NULL,
    action VARCHAR(50) NOT NULL,
    old_value LONGTEXT, -- অথবা JSON
    new_value LONGTEXT, -- অথবা JSON
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    INDEX (table_name), -- সার্চিং দ্রুত করার জন্য
    INDEX (created_at)  -- রিপোর্ট দ্রুত জেনারেট করার জন্য
);


----------- namespace Domain.Entities; -----------

public class AuditLog
{
    public long Id { get; set; }
    public int BranchCode { get; set; }
    public int UserId { get; set; }
    public string TableName { get; set; } = null!;
    public string Action { get; set; } = null!;  --DELETE, UPDATE, CREATE
    public string? OldValue { get; set; }
    public string? NewValue { get; set; }
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
}







------------- GLOBAL CARRIER -----------------

namespace CBS.Domain.Common;
public class Result<T>
    {
        public bool IsSuccess { get; }
        public T Data { get; }
        public string Message { get; }
        public List<string> Errors { get; }

        protected Result(bool isSuccess, T data, string message, List<string> errors = null)
        {
            IsSuccess = isSuccess;
            Data = data;
            Message = message;
            Errors = errors ?? new List<string>();
        }

        public static Result<T> Success(T data, string message = "Operation successful")
            => new Result<T>(true, data, message);

        public static Result<T> Failure(string message, List<string> errors = null)
            => new Result<T>(false, default, message, errors);
}


------------------ DTO ----------------
using System.ComponentModel.DataAnnotations;

namespace CBS.Application.DTO;

public record AuditLogCreateDTO(
    [Required(ErrorMessage = "Branch ID Required")]
    int BranchCode,

    [Required(ErrorMessage = "User ID Required")]
    int UserId,

    [Required(ErrorMessage = "Table Name Required")]
    string TableName,

    [Required(ErrorMessage = "Action Required")]
    string Action,

    string? OldValue,
    string? NewValue
);

-------------------------- Interface ----------------

using CBS.Application.DTO;
using CBS.Domain.Common;

namespace CBS.Application.Interfaces;

public interface IAuditLogService
{
    Task<Result<bool>> CreateAuditLogAsync(AuditLogCreateDTO dto);
}

------------------------- InterfaceService ----------------
using CBS.Application.DTO;
using CBS.Application.Interfaces;
using CBS.Domain.Common;
using Dapper;
using MySqlConnector;

namespace CBS.Infrastructure.Services;

public class AuditLogService : IAuditLogService
{
    private readonly MySqlDataSource _dataSource;

    public AuditLogService(MySqlDataSource dataSource)
    {
        _dataSource = dataSource;
    }

    public async Task<Result<bool>> CreateAuditLogAsync(AuditLogCreateDTO dto)
    {
        try
        {
            using var connection = await _dataSource.OpenConnectionAsync();

            string sql = @"INSERT INTO audit_logs 
                          (branch_code, user_id, table_name, action, old_value, new_value, created_at) 
                          VALUES 
                          (@BranchCode, @UserId, @TableName, @Action, @OldValue, @NewValue, NOW())";

            // Dapper will map record's data
            var result = await connection.ExecuteAsync(sql, dto);

            if (result > 0)
            {
                return Result<bool>.Success(true, "Audit log created successfully");
            }

            return Result<bool>.Failure("Failed to insert audit log");
        }
        catch (Exception ex)
        {
            //Loggin (Serilog/NLog) is must for Banking
            return Result<bool>.Failure($"Error: {ex.Message}");
        }
    }

}

---------------- Use ----------------
// audit log create(new data save so OldValue=null) 
var auditDto = new AuditLogCreateDTO(
    BranchCode: bdto.BranchCode , 
    UserId: 1,
    TableName: "branches",
    Action: "CREATE",
    OldValue: null,
    NewValue: $"Id: {newId}, Code: {bdto.BranchCode}, Name: {bdto.BranchName}"
);

var auditResult = await _auditLogService.CreateAuditLogAsync(auditDto);

if (!auditResult.IsSuccess)
{
    await transaction.RollbackAsync(); //If Audit failed no branch created 
    return Result<dynamic>.Failure("Audit log failed. Transaction rolled back.");
}

// commit transaciton if everything is ok
await transaction.CommitAsync();






--
