
Why this module first?
This module is not dependent to any..


 CREATE  TABLE branches (
    id INT AUTO_INCREMENT PRIMARY KEY,
    branch_code VARCHAR(10) UNIQUE NOT NULL,
    branch_name VARCHAR(100) NOT NULL,
    vault_balance DECIMAL(18, 2) DEFAULT 0.00,
    is_active BOOLEAN DEFAULT TRUE
);


CREATE TABLE audit_logs (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    branch_id INT NOT NULL,
    user_id INT,
    action VARCHAR(100),
    old_value VARCHAR(100),
    new_value VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (branch_id) REFERENCES branches(id),
    FOREIGN KEY (user_id) REFERENCES users(id)
);




→ Domain Layer
     → Branch Entities with Business Logic for user and Audit_log

→ Application-Layer
    → Common global message, show success / failed
    → Add  Audit_Log
    → Interface and DTO for
         → Create
         → Update
         → Inactive
             • soft delete

→ Infrastructure-Layer
    → Implement of Interfaces from Application-Layer and Audit_Log
    → DB-conn.
    → EF installation(DB,Tools, PDF)

→ Presentation-Layer
    → ViewModel
    → BranchController with CRUD and RBAC
    → Implement of Audit_Log
    → View
       → Create, Login
       → Show all (Update | Active | Inactive) → Search+Pagination
       → Update Branch info




######################################################################## 
                                CODE
######################################################################## 

namespace CBS.Domain.Common
{
    public class Result<T>
    {
        public bool IsSuccess { get; }
        public T Data { get; }
        public string Message { get; }
        public List<string> Errors { get; }

        protected Result(bool isSuccess, T data, string message, List<string> errors = null)
        {
            IsSuccess = isSuccess;
            Data = data;
            Message = message;
            Errors = errors ?? new List<string>();
        }

        public static Result<T> Success(T data, string message = "Operation successful") 
            => new Result<T>(true, data, message);

        public static Result<T> Failure(string message, List<string> errors = null) 
            => new Result<T>(false, default, message, errors);
    }
}

-----------------------

// Domain/Entities/AuditLog.cs
public class AuditLog
{
    public long Id { get; set; }
    public int BranchId { get; set; }
    public int? UserId { get; set; }
    public string Action { get; set; }
    public string OldValue { get; set; }
    public string NewValue { get; set; }
    public DateTime CreatedAt { get; set; } = DateTime.Now;
}

// Domain/Entities/Branch.cs
public class Branch
{
    public int Id { get; set; }
    public string BranchCode { get; set; }
    public string BranchName { get; set; }
    public decimal VaultBalance { get; private set; }
    public bool IsActive { get; private set; } = true;

   public Result<bool> UpdateVaultBalance(decimal amount) {
    if (VaultBalance < amount) return Result<bool>.Failure("Insufficient Vault Balance!");
    VaultBalance -= amount;
    return Result<bool>.Success(true);
}

    public void UpdateInfo(string code, string name)
    {
        BranchCode = code;
        BranchName = name;
    }

    public void Deactivate() => IsActive = false; // Soft Delete
    public void Activate() => IsActive = true;
}
